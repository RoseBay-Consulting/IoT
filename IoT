pragma solidity ^0.4.19;
contract Iot{
    event TransferLog(uint256);
  
    //address of the owner who have account on bank and control by client side 
    address public lawyeraddress;
    address public sonaddress;
    
    address public owneraddress ;
    address public vaultaddress;
    
    modifier onlySuperUser(address _from, address _to){
     assert((_from == owneraddress) || (_from == sonaddress ) || (_from ==lawyeraddress));
     assert(_to == vaultaddress);
     _;
    }
    
    mapping( 
        address =>uint256
        ) public currentholdingsof;
   
        //to send ether fuction must be called expicitly other wise revert
    function IoT(address _vaultaddress)public {
         lawyeraddress = 0x055650C2dEE3392aEb73D80cCd0B169C10D379f7;
         sonaddress = 0xf861131c1F106CeBE2ED690001AC0D3957d087cf;
         owneraddress = msg.sender;
         vaultaddress = _vaultaddress;
         valueRefactor();
    }
    
    function valueRefactor()internal{
        currentholdingsof[lawyeraddress] = 10;
        currentholdingsof[sonaddress] = 10;
        currentholdingsof[owneraddress]=20;
        currentholdingsof[vaultaddress]=0;        
    }
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        // Check if the sender has enough
        require(currentholdingsof[_from] >= _value);
        // Check for overflows
        require(currentholdingsof[_to] + _value > currentholdingsof[_to]);
        // Save this for an assertion in the future
        uint previousBalances = currentholdingsof[_from] + currentholdingsof[_to];
        // Subtract from the sender
        currentholdingsof[_from] -= _value;
        // Add the same to the recipient
        currentholdingsof[_to] += _value;
        
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(currentholdingsof[_from] + currentholdingsof[_to] == previousBalances);
    }

  function unlock()public onlySuperUser(msg.sender, vaultaddress)returns(bool){
    if(currentholdingsof[msg.sender] >= 10){
    _transfer(msg.sender, vaultaddress, currentholdingsof[msg.sender]);
        
        if(currentholdingsof[vaultaddress]>=20){
        emit TransferLog(currentholdingsof[vaultaddress]);
        }
    return true;
    }
    else return false;
  }
  
  
  function lock()public onlySuperUser(msg.sender, vaultaddress) returns(bool){
    if(currentholdingsof[vaultaddress] >= 20){
    valueRefactor();
    emit TransferLog(currentholdingsof[vaultaddress]);
    valueRefactor();
     return true;
      }
    else return false;
  }
}
pragma solidity ^0.4.19;
contract Iot{
    event TransferLog(address, address, uint256);
  
    //address of the owner who have account on bank and control by client side 
    address public owneraddress ;
    address public vaultaddress; 
    modifier onlySuperUser(address _from, address _to){
     assert(_from == owneraddress);
     assert(_to == vaultaddress);
     _;
    }
    mapping( 
        address =>uint256
        ) public currentholdingsof;
   
        //to send ether fuction must be called expicitly other wise revert
    function IoT(address _vaultaddress)public {
         owneraddress = msg.sender;
         vaultaddress = _vaultaddress;
        currentholdingsof[owneraddress] = 10;
    }
    
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        // Check if the sender has enough
        require(currentholdingsof[_from] >= _value);
        // Check for overflows
        require(currentholdingsof[_to] + _value > currentholdingsof[_to]);
        // Save this for an assertion in the future
        uint previousBalances = currentholdingsof[_from] + currentholdingsof[_to];
        // Subtract from the sender
        currentholdingsof[_from] -= _value;
        // Add the same to the recipient
        currentholdingsof[_to] += _value;
        
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(currentholdingsof[_from] + currentholdingsof[_to] == previousBalances);
    }

  function unlock(uint _value)public onlySuperUser(msg.sender, vaultaddress)returns(bool){
    if(currentholdingsof[msg.sender] >= 10){
    _transfer(msg.sender, vaultaddress, _value);
    emit TransferLog(msg.sender, vaultaddress, _value);
    return true;
    }
    else return false;
  }
  
  
  function lock( uint _value)public onlySuperUser(msg.sender, vaultaddress) returns(bool){
    if(currentholdingsof[vaultaddress] >= 10){
     _transfer(vaultaddress, msg.sender, _value);
     emit TransferLog(vaultaddress, msg.sender, _value);
     return true;
      }
    else return false;
  }
}